// Code generated by entc, DO NOT EDIT.

package ent

import (
	"bytes"
	"fmt"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
)

// Module is the model entity for the Module schema.
type Module struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Owner holds the value of the "owner" field.
	Owner string `json:"owner,omitempty"`
	// Namespace holds the value of the "namespace" field.
	Namespace string `json:"namespace,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Provider holds the value of the "provider" field.
	Provider string `json:"provider,omitempty"`
	// Description holds the value of the "description" field.
	Description string `json:"description,omitempty"`
	// Source holds the value of the "source" field.
	Source string `json:"source,omitempty"`
	// Downloads holds the value of the "downloads" field.
	Downloads int64 `json:"downloads,omitempty"`
	// PublishedAt holds the value of the "published_at" field.
	PublishedAt time.Time `json:"published_at,omitempty"`
	// InstallationID holds the value of the "installation_id" field.
	InstallationID int64 `json:"installation_id,omitempty"`
	// AppID holds the value of the "app_id" field.
	AppID int64 `json:"app_id,omitempty"`
	// RepoName holds the value of the "repo_name" field.
	RepoName string `json:"repo_name,omitempty"`
}

// FromRows scans the sql response data into Module.
func (m *Module) FromRows(rows *sql.Rows) error {
	var vm struct {
		ID             int
		Owner          sql.NullString
		Namespace      sql.NullString
		Name           sql.NullString
		Provider       sql.NullString
		Description    sql.NullString
		Source         sql.NullString
		Downloads      sql.NullInt64
		PublishedAt    sql.NullTime
		InstallationID sql.NullInt64
		AppID          sql.NullInt64
		RepoName       sql.NullString
	}
	// the order here should be the same as in the `module.Columns`.
	if err := rows.Scan(
		&vm.ID,
		&vm.Owner,
		&vm.Namespace,
		&vm.Name,
		&vm.Provider,
		&vm.Description,
		&vm.Source,
		&vm.Downloads,
		&vm.PublishedAt,
		&vm.InstallationID,
		&vm.AppID,
		&vm.RepoName,
	); err != nil {
		return err
	}
	m.ID = vm.ID
	m.Owner = vm.Owner.String
	m.Namespace = vm.Namespace.String
	m.Name = vm.Name.String
	m.Provider = vm.Provider.String
	m.Description = vm.Description.String
	m.Source = vm.Source.String
	m.Downloads = vm.Downloads.Int64
	m.PublishedAt = vm.PublishedAt.Time
	m.InstallationID = vm.InstallationID.Int64
	m.AppID = vm.AppID.Int64
	m.RepoName = vm.RepoName.String
	return nil
}

// QueryVersion queries the version edge of the Module.
func (m *Module) QueryVersion() *ModuleVersionQuery {
	return (&ModuleClient{m.config}).QueryVersion(m)
}

// Update returns a builder for updating this Module.
// Note that, you need to call Module.Unwrap() before calling this method, if this Module
// was returned from a transaction, and the transaction was committed or rolled back.
func (m *Module) Update() *ModuleUpdateOne {
	return (&ModuleClient{m.config}).UpdateOne(m)
}

// Unwrap unwraps the entity that was returned from a transaction after it was closed,
// so that all next queries will be executed through the driver which created the transaction.
func (m *Module) Unwrap() *Module {
	tx, ok := m.config.driver.(*txDriver)
	if !ok {
		panic("ent: Module is not a transactional entity")
	}
	m.config.driver = tx.drv
	return m
}

// String implements the fmt.Stringer.
func (m *Module) String() string {
	buf := bytes.NewBuffer(nil)
	buf.WriteString("Module(")
	buf.WriteString(fmt.Sprintf("id=%v", m.ID))
	buf.WriteString(fmt.Sprintf(", owner=%v", m.Owner))
	buf.WriteString(fmt.Sprintf(", namespace=%v", m.Namespace))
	buf.WriteString(fmt.Sprintf(", name=%v", m.Name))
	buf.WriteString(fmt.Sprintf(", provider=%v", m.Provider))
	buf.WriteString(fmt.Sprintf(", description=%v", m.Description))
	buf.WriteString(fmt.Sprintf(", source=%v", m.Source))
	buf.WriteString(fmt.Sprintf(", downloads=%v", m.Downloads))
	buf.WriteString(fmt.Sprintf(", published_at=%v", m.PublishedAt))
	buf.WriteString(fmt.Sprintf(", installation_id=%v", m.InstallationID))
	buf.WriteString(fmt.Sprintf(", app_id=%v", m.AppID))
	buf.WriteString(fmt.Sprintf(", repo_name=%v", m.RepoName))
	buf.WriteString(")")
	return buf.String()
}

// Modules is a parsable slice of Module.
type Modules []*Module

// FromRows scans the sql response data into Modules.
func (m *Modules) FromRows(rows *sql.Rows) error {
	for rows.Next() {
		vm := &Module{}
		if err := vm.FromRows(rows); err != nil {
			return err
		}
		*m = append(*m, vm)
	}
	return nil
}

func (m Modules) config(cfg config) {
	for _i := range m {
		m[_i].config = cfg
	}
}
