// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/meringu/terraform-private-registry/internal/ent/module"
	"github.com/meringu/terraform-private-registry/internal/ent/moduleversion"
)

// ModuleCreate is the builder for creating a Module entity.
type ModuleCreate struct {
	config
	owner           *string
	namespace       *string
	name            *string
	provider        *string
	description     *string
	source          *string
	downloads       *int64
	published_at    *time.Time
	installation_id *int64
	app_id          *int64
	repo_name       *string
	version         map[int]struct{}
}

// SetOwner sets the owner field.
func (mc *ModuleCreate) SetOwner(s string) *ModuleCreate {
	mc.owner = &s
	return mc
}

// SetNamespace sets the namespace field.
func (mc *ModuleCreate) SetNamespace(s string) *ModuleCreate {
	mc.namespace = &s
	return mc
}

// SetName sets the name field.
func (mc *ModuleCreate) SetName(s string) *ModuleCreate {
	mc.name = &s
	return mc
}

// SetProvider sets the provider field.
func (mc *ModuleCreate) SetProvider(s string) *ModuleCreate {
	mc.provider = &s
	return mc
}

// SetDescription sets the description field.
func (mc *ModuleCreate) SetDescription(s string) *ModuleCreate {
	mc.description = &s
	return mc
}

// SetSource sets the source field.
func (mc *ModuleCreate) SetSource(s string) *ModuleCreate {
	mc.source = &s
	return mc
}

// SetDownloads sets the downloads field.
func (mc *ModuleCreate) SetDownloads(i int64) *ModuleCreate {
	mc.downloads = &i
	return mc
}

// SetNillableDownloads sets the downloads field if the given value is not nil.
func (mc *ModuleCreate) SetNillableDownloads(i *int64) *ModuleCreate {
	if i != nil {
		mc.SetDownloads(*i)
	}
	return mc
}

// SetPublishedAt sets the published_at field.
func (mc *ModuleCreate) SetPublishedAt(t time.Time) *ModuleCreate {
	mc.published_at = &t
	return mc
}

// SetInstallationID sets the installation_id field.
func (mc *ModuleCreate) SetInstallationID(i int64) *ModuleCreate {
	mc.installation_id = &i
	return mc
}

// SetAppID sets the app_id field.
func (mc *ModuleCreate) SetAppID(i int64) *ModuleCreate {
	mc.app_id = &i
	return mc
}

// SetRepoName sets the repo_name field.
func (mc *ModuleCreate) SetRepoName(s string) *ModuleCreate {
	mc.repo_name = &s
	return mc
}

// AddVersionIDs adds the version edge to ModuleVersion by ids.
func (mc *ModuleCreate) AddVersionIDs(ids ...int) *ModuleCreate {
	if mc.version == nil {
		mc.version = make(map[int]struct{})
	}
	for i := range ids {
		mc.version[ids[i]] = struct{}{}
	}
	return mc
}

// AddVersion adds the version edges to ModuleVersion.
func (mc *ModuleCreate) AddVersion(m ...*ModuleVersion) *ModuleCreate {
	ids := make([]int, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return mc.AddVersionIDs(ids...)
}

// Save creates the Module in the database.
func (mc *ModuleCreate) Save(ctx context.Context) (*Module, error) {
	if mc.owner == nil {
		return nil, errors.New("ent: missing required field \"owner\"")
	}
	if mc.namespace == nil {
		return nil, errors.New("ent: missing required field \"namespace\"")
	}
	if mc.name == nil {
		return nil, errors.New("ent: missing required field \"name\"")
	}
	if mc.provider == nil {
		return nil, errors.New("ent: missing required field \"provider\"")
	}
	if mc.description == nil {
		return nil, errors.New("ent: missing required field \"description\"")
	}
	if mc.source == nil {
		return nil, errors.New("ent: missing required field \"source\"")
	}
	if mc.downloads == nil {
		v := module.DefaultDownloads
		mc.downloads = &v
	}
	if mc.published_at == nil {
		return nil, errors.New("ent: missing required field \"published_at\"")
	}
	if mc.installation_id == nil {
		return nil, errors.New("ent: missing required field \"installation_id\"")
	}
	if mc.app_id == nil {
		return nil, errors.New("ent: missing required field \"app_id\"")
	}
	if mc.repo_name == nil {
		return nil, errors.New("ent: missing required field \"repo_name\"")
	}
	return mc.sqlSave(ctx)
}

// SaveX calls Save and panics if Save returns an error.
func (mc *ModuleCreate) SaveX(ctx context.Context) *Module {
	v, err := mc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (mc *ModuleCreate) sqlSave(ctx context.Context) (*Module, error) {
	var (
		res sql.Result
		m   = &Module{config: mc.config}
	)
	tx, err := mc.driver.Tx(ctx)
	if err != nil {
		return nil, err
	}
	builder := sql.Insert(module.Table).Default(mc.driver.Dialect())
	if value := mc.owner; value != nil {
		builder.Set(module.FieldOwner, *value)
		m.Owner = *value
	}
	if value := mc.namespace; value != nil {
		builder.Set(module.FieldNamespace, *value)
		m.Namespace = *value
	}
	if value := mc.name; value != nil {
		builder.Set(module.FieldName, *value)
		m.Name = *value
	}
	if value := mc.provider; value != nil {
		builder.Set(module.FieldProvider, *value)
		m.Provider = *value
	}
	if value := mc.description; value != nil {
		builder.Set(module.FieldDescription, *value)
		m.Description = *value
	}
	if value := mc.source; value != nil {
		builder.Set(module.FieldSource, *value)
		m.Source = *value
	}
	if value := mc.downloads; value != nil {
		builder.Set(module.FieldDownloads, *value)
		m.Downloads = *value
	}
	if value := mc.published_at; value != nil {
		builder.Set(module.FieldPublishedAt, *value)
		m.PublishedAt = *value
	}
	if value := mc.installation_id; value != nil {
		builder.Set(module.FieldInstallationID, *value)
		m.InstallationID = *value
	}
	if value := mc.app_id; value != nil {
		builder.Set(module.FieldAppID, *value)
		m.AppID = *value
	}
	if value := mc.repo_name; value != nil {
		builder.Set(module.FieldRepoName, *value)
		m.RepoName = *value
	}
	query, args := builder.Query()
	if err := tx.Exec(ctx, query, args, &res); err != nil {
		return nil, rollback(tx, err)
	}
	id, err := res.LastInsertId()
	if err != nil {
		return nil, rollback(tx, err)
	}
	m.ID = int(id)
	if len(mc.version) > 0 {
		p := sql.P()
		for eid := range mc.version {
			p.Or().EQ(moduleversion.FieldID, eid)
		}
		query, args := sql.Update(module.VersionTable).
			Set(module.VersionColumn, id).
			Where(sql.And(p, sql.IsNull(module.VersionColumn))).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
		affected, err := res.RowsAffected()
		if err != nil {
			return nil, rollback(tx, err)
		}
		if int(affected) < len(mc.version) {
			return nil, rollback(tx, &ErrConstraintFailed{msg: fmt.Sprintf("one of \"version\" %v already connected to a different \"Module\"", keys(mc.version))})
		}
	}
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	return m, nil
}
